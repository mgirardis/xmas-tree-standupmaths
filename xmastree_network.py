#MIT License
#
#Copyright (c) 2020 standupmaths
#
#Permission is hereby granted, free of charge, to any person obtaining a copy
#of this software and associated documentation files (the "Software"), to deal
#in the Software without restriction, including without limitation the rights
#to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#copies of the Software, and to permit persons to whom the Software is
#furnished to do so, subject to the following conditions:
#
#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.
#
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#SOFTWARE.

def xmaslight():
    # This is the code from my 
    
    #NOTE THE LEDS ARE GRB COLOUR (NOT RGB)
    
    # Here are the libraries I am currently using:
    import time
    import board
    import neopixel
    import re
    import math
    # FOR DEBUGGING PURPOSE
    #import matplotlib.pyplot as plt
    #import matplotlib.animation as animation
    
    # You are welcome to add any of these:
    # import random
    import numpy
    # import scipy
    import sys
    
    # If you want to have user changable values, they need to be entered from the command line
    # so import sys sys and use sys.argv[0] etc
    # some_value = int(sys.argv[0])
    
    # IMPORT THE COORDINATES (please don't break this bit)
    
    coordfilename = "Python/coords.txt"
    # FOR DEBUGGING PURPOSE
    #coordfilename = "xmastree2020/coords.txt"
	
    fin = open(coordfilename,'r')
    coords_raw = fin.readlines()
    
    coords_bits = [i.split(",") for i in coords_raw]
    
    coords = []
    
    for slab in coords_bits:
        new_coord = []
        for i in slab:
            new_coord.append(int(re.sub(r'[^-\d]','', i)))
        coords.append(new_coord)
    
    #set up the pixels (AKA 'LEDs')
    PIXEL_COUNT = len(coords) # this should be 500
    
    pixels = neopixel.NeoPixel(board.D18, PIXEL_COUNT, auto_write=False)
    # FOR DEBUGGING PURPOSE
    #pixels = [ 0 for i in range(PIXEL_COUNT) ]
    
    
    # YOU CAN EDIT FROM HERE DOWN
    
    # This program is intended to make a neuronal network out of the tree's LEDs.
    #
    # By neuronal network I mean:
    # the light of each LED will be set according to a dynamic variable V
    # that stands for a model of the electric potential in the membrane of a real neuron.
    # And these 'neurons' (i.e., LEDs) will have connections between them
    # that obey the dynamics of chemical synapses in the brain represented by the variable S.
    # The network is built according to a 'cubic-like' lattice: i.e.,
    # a given LED receives input from the closest LEDs in each of the 6 spatial directions.
    # Thus, the 'synapse' is represented by a 'virtual' connection, and not a physical one (i.e., the LED wire)
    # I implemented other 2 types of networks:
    #     a surface networks (only LEDs in the surface of the tree cone 'talk' to each other)
    #     a proximity network (only LEDs within a radius R of each other are connected)
    #
    # to visualize the network generated by this algorithm, please run
    # python view_tree_network.py

    # first we need to define (a lot of) functions
    def memb_potential_to_01(V):
        # V -> dynamic variable (defined in [-1,1])
        # the formula below is just a smart way to map
        # [-1,1] to [0,1], emphasizing bright colors (i.e., colors close to 1)
        # [0,1] is then mapped on the color_arr below
        if type(V) is numpy.ndarray:
            return ((V[:,0]+1.0)*0.5)**4 # raising to 4 is just to emphasize bright colors
        else:
            return ((V+1.0)*0.5)**4 # raising to 4 is just to emphasize bright colors
    def memb_potential_to_coloridx(V,n_colors):
        # V -> dynamic variable
        # n_colors -> total number of colors
        return numpy.floor(n_colors*memb_potential_to_01(V)).astype(int)
    def create_input_lists(neigh):
        # given a list of neighbors, where neigh[i] is a list of inputs to node i
        # generate the list of inputs to be used in the simulation
        presyn_neuron_list = [n for sublist in neigh for n in sublist]
        cs = numpy.insert(numpy.cumsum([ n.size for n in neigh ]),0,0)
        input_list = [ numpy.arange(a,b) for a,b in zip(cs[:-1],cs[1:]) ]
        return input_list,presyn_neuron_list
    def generate_list_of_neighbors(r,R=0.0,on_conic_surface_only=False):
        # generates a network of "pixels"
        # each pixel in position r[i,:] identifies its 6 closest neighbors and should receive a connection from it
        # if R is given, includes all pixels within a radius R of r[i,:] as a neighbor
        # the 6 neighbors are chosen such that each one is positioned to the left, right, top, bottom, front or back of each pixel (i.e., a simple attempt of a cubic lattice)
        #
        # r -> position vector (each line is the position of each pixel)
        # R -> neighborhood ball around each pixel
        # on_conic_surface_only -> if true, only links pixels that are on the conic shell of the tree
        #
        # returns:
        #    list of neighbors
        #     neigh[i] -> list of 6 "pixels" closest to i
        def is_left_neigh(u,v):
            # u and v are two vectors on the x,y plane
            # u may be a list of vectors (one vector per row)
            return numpy.dot(u,[-v[1],v[0]])>0.0 # # the vector [-v[1],v[0]] is the 90-deg CCW rotated version of v
        def get_first_val_not_in_list(v,l):  # auxiliary function
            # returns first value in v that is not in l
            if v.size == 0:
                return None
            n = len(v)
            i = 0
            while i < n:
                if not (v[i] in l):
                    return v[i]
                i+=1
        if on_conic_surface_only:
            # only adds 4 neighbors (top, bottom, left, right) that are outside of the cone defined by the estimated tree cone parameters
            # cone equation (x**2 + y**2)/c**2 = (z-z0)**2
            z0 = numpy.max(r[:,2]) # cone height above the z=0 plane
            h = z0 + numpy.abs(numpy.min(r[:,2])) # cone total height
            base_r = (numpy.max(  (numpy.max(r[:,1]),numpy.max(r[:,0]))   ) + numpy.abs(numpy.min(  ( numpy.min(r[:,1]),numpy.min(r[:,0]) )  )))/2.0 # cone base radius
            c = base_r / h # cone opening radius (defined by wolfram https://mathworld.wolfram.com/Cone.html )
            #z_cone = lambda x,y,z0,c,s: z0+s*numpy.sqrt((x**2+y**2)/(c**2)) # s is the concavity of the cone: -1 turned down, +1 turned up
            cone_r_sqr = lambda z,z0,c: (c*(z-z0))**2
            outside_cone = (r[:,0]**2+r[:,1]**2) > cone_r_sqr(r[:,2],z0,c)
            pixel_list = numpy.nonzero(outside_cone)[0]
            r_out = r[outside_cone,:]

            neigh = [ numpy.array([],dtype=int) for i in range(r.shape[0]) ]
            for i,r0 in enumerate(r_out):
                # a radius is not given, hence returns a crystalline-like cubic-like structure :P
                pixel_list_sorted = numpy.argsort(numpy.linalg.norm(r_out-r0,axis=1)) # sorted by Euler distance to r0
                rs = r_out[pixel_list_sorted,:] # list of positions from the closest to the farthest one to r0
                local_neigh_list = [] # local neighbor list
                x1_neigh = get_first_val_not_in_list(numpy.nonzero( is_left_neigh(rs[:,:2],r0[:2]) )[0],local_neigh_list) # gets first neighbor to the left that is not added yet
                if x1_neigh:
                    local_neigh_list.append(x1_neigh)
                x2_neigh = get_first_val_not_in_list(numpy.nonzero( numpy.logical_not(is_left_neigh(rs[:,:2],r0[:2])) )[0],local_neigh_list) # gets first neighbor to the right that is not added yet
                if x2_neigh:
                    local_neigh_list.append(x2_neigh)
                z1_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,2]<r0[2])[0],local_neigh_list) # gets first neighbor to the top that is not added yet
                if z1_neigh:
                    local_neigh_list.append(z1_neigh)
                z2_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,2]>r0[2])[0],local_neigh_list) # gets first neighbor to the bottom that is not added yet
                if z2_neigh:
                    local_neigh_list.append(z2_neigh)
                neigh[pixel_list[i]] = pixel_list[pixel_list_sorted[local_neigh_list]] # adds neighbors
            return neigh
                
        neigh = []
        for r0 in r:
            if (R>0.0): # a neighborhood radius is given
                neigh.append(numpy.nonzero(numpy.linalg.norm(r-r0,axis=1)<R)[0])
            else:
                # a radius is not given, hence returns a crystalline-like cubic-like structure :P
                pixel_list_sorted = numpy.argsort(numpy.linalg.norm(r-r0,axis=1)) # sorted by Euler distance to r0
                rs = r[pixel_list_sorted,:] # list of positions from the closest to the farthest one to r0
                local_neigh_list = [] # local neighbor list
                x1_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,0]<r0[0])[0],local_neigh_list) # gets first neighbor to the left that is not added yet
                if x1_neigh:
                    local_neigh_list.append(x1_neigh)
                x2_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,0]>r0[0])[0],local_neigh_list) # gets first neighbor to the right that is not added yet
                if x2_neigh:
                    local_neigh_list.append(x2_neigh)
                y1_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,1]<r0[1])[0],local_neigh_list) # gets first neighbor to the back that is not added yet
                if y1_neigh:
                    local_neigh_list.append(y1_neigh)
                y2_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,1]>r0[1])[0],local_neigh_list) # gets first neighbor to the front that is not added yet
                if y2_neigh:
                    local_neigh_list.append(y2_neigh)
                z1_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,2]<r0[2])[0],local_neigh_list) # gets first neighbor to the top that is not added yet
                if z1_neigh:
                    local_neigh_list.append(z1_neigh)
                z2_neigh = get_first_val_not_in_list(numpy.nonzero(rs[:,2]>r0[2])[0],local_neigh_list) # gets first neighbor to the bottom that is not added yet
                if z2_neigh:
                    local_neigh_list.append(z2_neigh)
                neigh.append(pixel_list_sorted[local_neigh_list]) # adds neighbors
        return neigh
    def build_network(r_nodes,R=0.0,conic_surface_only=False):
        # r_nodes vector of coordinates of each pixel
        # R connection radius
        # if R is zero, generates an attempt of a cubic-like lattice, otherwise connects all pixels within a radius R of each other
        neigh = generate_list_of_neighbors(r_nodes,R,on_conic_surface_only=conic_surface_only)
        # creates the interaction lists between dynamic variables
        input_list,presyn_neuron_list = create_input_lists(neigh)
        # creates dynamic variables
        N = len(neigh) # number of neurons (or pixels)
        Nsyn = len(presyn_neuron_list)
        V = numpy.zeros((N,3)) # membrane potential (dynamic variables) of each neuron (pixel)
        S = numpy.zeros((Nsyn,2)) # synaptic current input generated by each pixel towards each of its postsynaptic pixels
        return V,S,input_list,presyn_neuron_list
    def get_neuron_resting_state(neuron_map_iter,par,T=20000):
        V = -0.9*numpy.ones((1,3))
        t = 0
        while t<T:
            V = neuron_map_iter(0,V,par,[],0.0)
            t+=1
        return V
    def set_initial_condition(V,neuron_map_iter,parNeuron,V0_type=None):
        if type(V0_type) is type(None):
            V0 = get_neuron_resting_state(neuron_map_iter,parNeuron)
        else:
            if type(V0_type) is str:
                if V0_type == 'rest':
                    V0 = get_neuron_resting_state(neuron_map_iter,parNeuron)
                elif V0_type == 'random':
                    V = 2.0*numpy.random.random_sample(V.shape)-1.0
                    return V
                else:
                    raise ValueError('V0_type must be either an array or list with 3 elements or one of the following: rest, random')
            elif type(V0_type) is list:
                V0 = numpy.asarray(V0_type)
            else:
                if type(V0_type) is numpy.ndarray:
                    V0 = V0_type
                else:
                    raise ValueError('V0_type must be either an array or list with 3 elements or one of the following: rest, random')
        i = 0
        while i < V.shape[0]:
            V[i,:] = V0.copy()
            i+=1
        return V
    def synapse_map(i,S,par,Vpre):
        # par[0] -> J, par[1] -> noise amplitude, par[2] -> 1/tau_f, par[3] -> 1/tau_g
        thetaJ =  par[0] + (par[1] * numpy.random.random()) if Vpre > 0.0 else 0.0
        S[i,0] = (1.0 - par[2]) * S[i,0] + S[i,1]
        S[i,1] = (1.0 - par[3]) * S[i,1] + thetaJ
        return S
    def logistic_func(u):
        return u / (1 + (u if u > 0.0 else -u)) # u/(1+|u|)
    def neuron_map_log(i,V,par,S,Iext):
        # par[0] -> K, par[1] -> 1/T, par[2] -> d, par[3] -> l, par[4] -> xR
        Vprev = V[i,0]
        V[i,0] = logistic_func((V[i,0] - par[0] * V[i,1] + V[i,2] + numpy.sum(S)+Iext)*par[1])
        V[i,1] = Vprev
        V[i,2] = (1.0 - par[2]) * V[i,2] - par[3] * (Vprev - par[4])
        return V
    def neuron_map_tanh(i,V,par,S,Iext):
        # par[0] -> K, par[1] -> 1/T, par[2] -> d, par[3] -> l, par[4] -> xR
        Vprev = V[i,0]
        V[i,0] = numpy.tanh((V[i,0] - par[0] * V[i,1] + V[i,2] + numpy.sum(S)+Iext)*par[1])
        V[i,1] = Vprev
        V[i,2] = (1.0 - par[2]) * V[i,2] - par[3] * (Vprev - par[4])
        return V
    def network_time_step(neuron_map_iter,V,parNeuron,input_list,S,presyn_neuron_list,parSyn,P_poisson):
        # neuron_map_iter -> function that iterates the neuron (either neuron_map_log or neuron_map_tanh)
        # V -> numpy.ndarray with shape (N,3), where N is the number of neurons (pixels), containing the membrane potential of neurons
        # parNeuron -> list of six parameters that is passed to the neuron_map_iter
        # input_list -> list of neighbors of each pixel, such that element i: list of neighbors (rows of S) that send input to pixel i
        # S -> numpy.ndarray with shape (Nsyn,2), where Nsyn is the total number of synapses (connections between pixels), containg the synaptic current of each connection
        # presyn_neuron_list -> list of presynaptic neurons (i.e. rows of V) that generates each synapse, such that pixel given by presyn_neuron_list[i] generates synapse S[i,:]
        # parSyn -> list of 4 parameters that is passed to synapse_map function
        # P_poisson -> probability of generating a random activation of a random pixel
        if numpy.random.random() < P_poisson:
            k = numpy.random.randint(V.shape[0]) # selects a random pixel to stimulate
            Iext = parNeuron[5] # external kick
        else:
            k = 0
            Iext = 0.0
        i = 0
        while i < S.shape[0]:
            S = synapse_map(i,S,parSyn,V[presyn_neuron_list[i],0]) # evolve the synaptic equations
            i+=1
        i = 0
        while i < k:
            V = neuron_map_iter(i,V,parNeuron,S[input_list[i],0],0.0) # evolve the pixel (neuron) equations
            i+=1
        V = neuron_map_iter(i,V,parNeuron,S[input_list[i],0],Iext) # evolve the pixel (neuron) equations
        i+=1
        while i < V.shape[0]:
            V = neuron_map_iter(i,V,parNeuron,S[input_list[i],0],0.0) # evolve the pixel (neuron) equations
            i+=1
        return V,S

    # then we define the color matrix for the pixels
    # these colors are intended to give a gradient effect (lighter to darker colors)
    # these colors are generated from the viridis colormap of matplotlib
    # color_arr = matplotlib.pyplot.get_cmap('viridis')(numpy.linspace(0,1,20))
    # other colormaps can be used at will, just generate the color matrix, invert the G and R and put it here
    # INVERTED Green and Red columns: GRB format
    color_arr = [[0.004874, 0.267004, 0.329415 ],
                 [0.078907, 0.280894, 0.402329 ],
                 [0.145912, 0.28229 , 0.46151  ],
                 [0.214069, 0.270595, 0.507052 ],
                 [0.27429 , 0.250425, 0.533103 ],
                 [0.334994, 0.223925, 0.548053 ],
                 [0.387607, 0.19943 , 0.554642 ],
                 [0.44129 , 0.175841, 0.557685 ],
                 [0.489624, 0.15627 , 0.557936 ],
                 [0.541173, 0.136408, 0.554483 ],
                 [0.589055, 0.121831, 0.545623 ],
                 [0.640461, 0.12478 , 0.527068 ],
                 [0.687316, 0.162016, 0.499129 ],
                 [0.735588, 0.239374, 0.455688 ],
                 [0.777018, 0.335885, 0.402049 ],
                 [0.816363, 0.458674, 0.329727 ],
                 [0.846661, 0.585678, 0.249897 ],
                 [0.871916, 0.730889, 0.156029 ],
                 [0.889868, 0.866013, 0.095953 ],
                 [0.906157, 0.993248, 0.143936 ]]
    n_colors = len(color_arr)
    
    # we may get an input from the user to define the dynamics of the network
    # 'spiral' means that the system displays 'spiral waves' (or at least, if it were a 2d lattice, it would display spiral waves)
    # 'sync' means that the system displays bursts of synchronized activity every now and then
    # note: these behaviors are not hard coded! they emerge from the interaction between LEDs
    sim_setting = sys.argv[1] if len(sys.argv) > 1 else 'spiral'
    if sim_setting != 'spiral' and sim_setting != 'sync':
        print('unknown simulation setting')
        return 0

    # we may also get an input from the user to determine the type of the network
    # if R_connection == 0.0, it means a 'cubic-lattice-like' network is generated
    # otherwise, it defines the connection radius between LEDs (if conic_surface_only is not set)
    R_connection = float(sys.argv[2]) if len(sys.argv)>2 else 0.0 # if 0, generates a cubic lattice; if > 0, then connects all pixels that are within radius R of each other

    # another parameter we may get from the user
    # if true, only connects neurons on the surface of the tree cone
    conic_surface_only = (sys.argv[3]=='surf') if len(sys.argv)>3 else False
    surf_is_set = len(sys.argv)>3

    print('chosen settings: %s'%sim_setting)

    if sim_setting == 'spiral':
        # setting external stimulus parameters
        r_Poisson = 0.2 # rate of Poisson process
        # setting neuron parameters
        parNeuron_tanh = [ 0.6, 1.0/0.35, 0.001, 0.008, -0.7, 0.1 ] # par[0] -> K, par[1] -> 1/T, par[2] -> d, par[3] -> l, par[4] -> xR, par[5] -> Iext
        neuron_map_iter = neuron_map_tanh
        parNeuron = parNeuron_tanh
        V0 = None # uses default initial condition
        # setting synapse parameters
        parSynapse = [-0.2,0.0,1.0/2.0,1.0/2.0] # par[0] -> J, par[1] -> noise amplitude, par[2] -> 1/tau_f, par[3] -> 1/tau_g
        if not surf_is_set:
            conic_surface_only = False
    else:
        # setting external stimulus parameters
        r_Poisson = 0.0 # rate of Poisson process
        # setting neuron parameters
        parNeuron_tanh = [ 0.6, 1.0/0.35, 0.001, 0.001, -0.5, 0.1 ] # par[0] -> K, par[1] -> 1/T, par[2] -> d, par[3] -> l, par[4] -> xR, par[5] -> Iext
        neuron_map_iter = neuron_map_tanh
        parNeuron = parNeuron_tanh
        V0 = 'rest'
        # setting synapse parameters
        parSynapse = [-0.2,0.05,1.0/5.0,1.0/5.0] # par[0] -> J, par[1] -> noise amplitude, par[2] -> 1/tau_f, par[3] -> 1/tau_g
        if not surf_is_set:
            conic_surface_only = True
    
    # here the fun begins
    # now, we calculate a possible Poisson process that will light a LED randomly in space and time if r_Poisson > 0
    P_Poisson = 1.0-numpy.exp(-r_Poisson) # probability of firing is constant

    # now we create the network and set the initial conditions
    V,S,input_list,presyn_neuron_list = build_network(numpy.asarray(coords,dtype=float),R=R_connection,conic_surface_only=conic_surface_only)
    V = set_initial_condition(V,neuron_map_iter,parNeuron,V0)

    # pause between cycles (normally zero as it is already quite slow)
    slow = 0

    # yes, I just run which run is true
    run = 1
    # FOR DEBUGGING PURPOSE
    #MAX_TIME = 50 # debugging purposes
    #frames = []
    #frames.append(numpy.array(color_arr)[memb_potential_to_coloridx(V,n_colors)].reshape( (20,25,3) ))
    #t=0
    while run == 1:

        # yep, that's pretty much all we want to do before lighting up the tree
        # here, we iterate the neuron and synapse equations
        V,S = network_time_step(neuron_map_iter,V,parNeuron,input_list,S,presyn_neuron_list,parSynapse,P_Poisson)

        # are you tired?
        time.sleep(slow)
        
        # setting the LED colors
        LED = 0
        while LED < len(coords):
            pixels[LED] = color_arr[memb_potential_to_coloridx(V[LED,0],n_colors)]
            LED += 1

        # use the show() option as rarely as possible as it takes ages
        # do not use show() each time you change a LED but rather wait until you have changed them all
        #pixels.show()

        # FOR DEBUGGING PURPOSE
        #frames.append(numpy.array(pixels).reshape( (20,25,3) ))
        #t+=1
        #if t >= MAX_TIME:
        #    break
        
    # FOR DEBUGGING PURPOSE
    #def animate(t,pdata,frames):
    #    pdata=plt.imshow(frames[t])
    #    return pdata,
    #fh = plt.figure()
    #pdata = plt.imshow(frames[0])
    #ani = animation.FuncAnimation(fh, animate, frames=len(frames), fargs=(pdata,frames), interval=int(0.01*1000), blit=True, repeat=True)
    #plt.show()
        
        
    return 'DONE'


# yes, I just put this at the bottom so it auto runs
xmaslight()
